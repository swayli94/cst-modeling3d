'''
Diamond wing
'''

import numpy as np
from scipy.interpolate import interp1d

from cst_modeling.io import plot3d_to_igs
from cst_modeling.basic import BasicSection, BasicSurface
from cst_modeling.section import dist_clustcos, cst_foil


def base_shape(x_ref: np.ndarray, x_LE: float, x_TE: float, 
               l_LE: float, l_TE: float, h: float, rr: float, 
               a_LE=0.0, a_TE=0.0, i_split=None):
    '''
    Base shape function of wing sections.
    
    >>> x, y = base_shape(x_ref, x_LE, x_TE, l_LE, l_TE, h, rr, a_LE=0.0, a_TE=0.0, i_split=None)
    
    ### Inputs:
    ```text
    x_ref:  ndarray [nn], [0,1]
    x_LE:   leading edge location
    x_TE:   trailing edge location
    l_LE:   length of leading edge curve
    l_TE:   length of trailing edge ramp
    h:      height
    rr:     relative radius of leading edge
    a_LE:   angle (deg) of the slope at leading  edge (a>0 => dy/dx>0)
    a_TE:   angle (deg) of the slope at trailing edge (a<0 => dy/dx<0)
    i_split:    active when leading edge and trailing edge curves are intersected
    ```
    '''
    
    l0 = x_TE - x_LE
    
    if abs(l0)<=1e-10:
        return np.ones_like(x_ref)*x_LE, np.zeros_like(x_ref)
    
    x = x_ref*l0+x_LE
    y = np.ones_like(x)*h
    
    r_LE = l_LE/l0
    r_TE = l_TE/l0
    
    def camber(x_):
        dy_LE = np.tan(a_LE/180.0*np.pi)*l0
        dy_TE = np.tan(a_TE/180.0*np.pi)*l0
        a = dy_LE + dy_TE
        b = -2*dy_LE-dy_TE
        c = dy_LE
        dy = a*x_**3+b*x_**2+c*x_
        return dy
    
    if l_LE+l_TE<=l0:
        
        i_LE = np.argmin(np.abs(x_ref-r_LE))+1
        i_TE = np.argmin(np.abs(x_ref-1+r_TE))-1
        y[:i_LE] = general_eqn(x_ref[:i_LE],   r_LE, rr, h)
        y[i_TE:] = general_eqn(1-x_ref[i_TE:], r_TE, 0., h)
        
        return x, y+camber(x_ref)
        
    else:
        
        y_le = general_eqn(x_ref,   r_LE, rr, h)
        y_te = general_eqn(1-x_ref, r_TE, 0., h)
        i_IT = np.argmin(np.abs(y_le-y_te))

        #* Locate intersection point
        x_m = x_ref[i_IT]
        x_l = x_ref[i_IT-1] # y_le(x_l) < y_te(x_l)
        x_r = x_ref[i_IT+1] # y_le(x_r) > y_te(x_r)
        for _ in range(10):
            x_m = 0.5*(x_l+x_r)
            d_m = general_eqn(np.array([x_m]), r_LE, rr, h) - general_eqn(np.array([1-x_m]), r_TE, 0., h)
            if d_m < -1e-10:
                x_l = x_m
            elif d_m > 1e-10:
                x_r = x_m
            else:
                break
        
        y_m = general_eqn(np.array([x_m]), r_LE, rr, h)[0]
        
        if i_split == None:
            
            y = np.concatenate((y_le[:i_IT], y_te[i_IT:]))
            y[i_IT] = y_m
            
            return x, y+camber(x_ref)
            
        else:
            
            nn = x_ref.shape[0]
            x_le = dist_clustcos(i_split,      a0=0.01, a1=0.96, beta=2)*x_m
            x_te = dist_clustcos(nn-i_split+1, a0=0.05, a1=0.96)*(1.0-x_m)+x_m
            y_le = general_eqn(x_le,   r_LE, rr, h)
            y_te = general_eqn(1-x_te, r_TE, 0., h)
            
            xx = np.concatenate((x_le[:, np.newaxis], x_te[1:, np.newaxis]), axis=0)
            yy = np.concatenate((y_le[:, np.newaxis], y_te[1:, np.newaxis]), axis=0)
            xx = xx[:,0]*l0+x_LE
            yy = yy[:,0]
            xx[i_split-1] = x_m*l0+x_LE
            yy[i_split-1] = y_m
            
            return xx, yy+camber((xx-x_LE)/l0)

def general_eqn(x: np.ndarray, l: float, rr: float, h: float):
    '''
    General equations to define the leading edge semithickness, 
    the flat plate semithickness, the trailing edge closure semithickness,
    and the tranverse radius of the sting fairing.

    >>> phi = general_eqn(x, l, rr, t) # phi >= 0

    Experimental Surface Pressure Data Obtained on 65° Delta Wing Across Reynolds Number
    and Mach Number Ranges (Volume 2—Small-Radius Leading Edges)

    https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19960025648.pdf

    ### Inputs:
    ```text
    x:      current location
    l:      range of x
    rr:     relative radius
    h:      max phi
    ```
    '''
    a = np.sqrt(2*rr*h)
    b = -15/8.*a + 3*h
    c = 5/4.*a - 3*h
    d = -3/8.*a + h
    
    xi  = x/l
    
    for i in range(xi.shape[0]):
        xi[i] = max(0.0, min(1.0, xi[i]))

    phi = a*np.sqrt(xi)+b*xi+c*np.power(xi,2)+d*np.power(xi,3)

    return phi


class Section(BasicSection):
    '''
    Section 3D curve generated by CST foil and base shape (upper & lower surface)
    
    ### Inputs:
    ```text
    xLE, yLE, zLE:  coordinates of the leading edge
    xTE:            X coordinate of the trailing edge
    l_LE, l_TE:     length of the LE and TE region
    h:              height of the base shape
    thick:          maximum thickness of the section
    rr:             relative radius of base shape function leading edge
    ```
    '''
    def __init__(self, xLE, yLE, zLE, xTE, l_LE, l_TE, h, thick, rr, cst_u: np.ndarray, cst_l: np.ndarray,
               x_ref, twist=0.0, tail=0.0, aLE=0.0, aTE=0.0, i_split=None):

        chord = xTE - xLE
        
        super().__init__(thick=thick, chord=chord, twist=twist)
        
        self.xLE = xLE
        self.yLE = yLE
        self.zLE = zLE
        self.tail = tail

        #* Base shape
        x_, self.base_yu = base_shape(x_ref, xLE, xTE, l_LE, l_TE, h, rr, a_LE= aLE, a_TE= aTE, i_split=i_split)
        x_, self.base_yl = base_shape(x_ref, xLE, xTE, l_LE, l_TE, h, rr, a_LE=-aLE, a_TE=-aTE, i_split=i_split)
        h_max_base = np.max(self.base_yu)
        
        #* 2D unit airfoil
        
        rel_thick = (thick-2*h_max_base)/chord
        if rel_thick < 0:
            self.base_yu = self.base_yu * thick/h_max_base/2
            self.base_yl = self.base_yl * thick/h_max_base/2
        
        r_ = np.max(np.abs(cst_u))>1E-6 or np.max(np.abs(cst_l))>1E-6
        
        if chord > 0 and r_ > 0:
            
            self.cst_u = cst_u.copy()
            self.cst_l = cst_l.copy()
            
            self.xx, self.cst_yu, self.cst_yl, self.thick, self.RLE = cst_foil(x_ref.shape[0],
            self.cst_u, self.cst_l, x=(x_-xLE)/chord, t=rel_thick, tail=tail/chord)
            
            if rel_thick < 0:
                camber = -0.5*(self.cst_yu+self.cst_yl) # negative sign is due to rel_thick < 0
                self.yu = camber + self.base_yu/chord
                self.yl = camber - self.base_yl/chord
            else:
                self.yu = r_*self.cst_yu + self.base_yu/chord
                self.yl = r_*self.cst_yl - self.base_yl/chord
            
        else:
            self.xx = np.zeros_like(x_ref)
            self.yu = self.base_yu
            self.yl = self.base_yl

        #* 3D airfoil
        self.section()


class Wing(BasicSurface):
    
    def __init__(self, sections: list, ns=101):
        
        super().__init__(n_sec=len(sections), name='Wing', nn=sections[0].x.shape[0], ns=ns, projection=True)
        
        self.secs = sections
        
        self.layout_center()

        for i in range(self.n_sec-1):
            surf = self.section2surf(self.secs[i], self.secs[i+1], ns=self.ns)
            self.surfs.append(surf)


def layout(SweptAngle_LE: float, AspectRatio: float, Anhedral: float, Section_zRatio: list):
    '''
    Calculate Layout parameters
    '''
    zTip = AspectRatio/4
    yTip = zTip*np.tan(Anhedral/180.0*np.pi)
    xTip = zTip*np.tan(SweptAngle_LE/180.0*np.pi)
    
    rz = np.array(Section_zRatio)
    xLEs = rz*xTip
    yLEs = rz*yTip
    zLEs = rz*zTip
    xTEs = (1-rz)+ rz*xTip
    
    SweptAngle_TE = np.arctan((1-xTip)/zTip)/np.pi*180
    Area = zTip
    
    return xLEs, yLEs, zLEs, xTEs, SweptAngle_TE, Area
    
def rel_thick_dist(z, zTip: float):
    
    f = interp1d([0.0, 1/3, 1.0], [0.10, 0.07, 0.04], kind='quadratic')

    return f(z/zTip)
    

if __name__ == '__main__':


    Section_zRatio = [0.0, 0.15, 0.33, 0.7, 0.98]
    SweptAngle_LE  = 55
    AspectRatio    = 2.0
    Anhedral       = 0.0
    
    CST_Us = [
        [0.0, 0.3, 1.0, 0.5, 1.0, 2.0],
        [0.0, 0.3, 0.5, 0.8, 0.5, 0.5],
        [0.0, 0.7, 0.7, 0.0],
        [0.0, 1.0, 0.5, 0.0],
        [0.0, 0.1, 0.1, 0.0],
    ]
    
    CST_Ls = [
        [0.0, -0.2, -0.4, 0.0],
        [0.0, -0.1, -0.2, 0.0],
        [0.0, -0.1, 0.0],
        [0.0, -0.1, 0.0],
        [0.0, -0.1, 0.0],
    ]
    
    nSec = len(Section_zRatio)
    xLEs, yLEs, zLEs, xTEs, SweptAngle_TE, Area = layout(SweptAngle_LE, AspectRatio, Anhedral, Section_zRatio)
    rel_thicks = rel_thick_dist(zLEs, zLEs[-1])
    thicks = np.multiply(rel_thicks, xTEs-xLEs)
    
    print('Leading  edge swept angle = %.1f deg'%(SweptAngle_LE))
    print('Trailing edge swept angle = %.1f deg'%(SweptAngle_TE))
    print('Aspect ratio =              %.1f'%(AspectRatio))
    print('Anhedral angle =            %.1f deg'%(Anhedral))
    print('Span =                      %.2f'%(zLEs[-1]*2))
    print('Area =                      %.2f'%(Area))
    
    x_ref= dist_clustcos(201, a0=0.0079, a1=0.96, beta=2)
    l_LE = 0.3
    l_TE = 0.3
    hh = 0.01
    rr = 0.02
    
    secs = []
    for i in range(nSec):
        secs.append(Section(xLEs[i], yLEs[i], zLEs[i], xTEs[i], l_LE, l_TE, hh, thicks[i], rr,
                            np.array(CST_Us[i]), np.array(CST_Ls[i]), x_ref, aLE=0.0, aTE=0.0, i_split=None))
    
    diamond = Wing(secs, ns=31)
    diamond.smooth(0, nSec-1, dyn0=0, ratio_end=10)
    diamond.output_tecplot(fname='Wing.dat', one_piece=False)

    diamond.scale(scale=1000)
    diamond.output_plot3d(fname='Wing.grd')
    plot3d_to_igs(fname='Wing')

